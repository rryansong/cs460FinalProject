<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Light Floor Demo</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // --- Renderer ---
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- Scene & Camera ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x02040a);

  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(0, 6, 10);
  camera.lookAt(0, 0, 0);

  // --- Controls (zoom, rotate, pan) ---
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = true;
  controls.enableZoom = true; // mouse wheel zoom
  controls.minDistance = 3;   // closest zoom
  controls.maxDistance = 40;  // farthest zoom
  controls.target.set(0, 0, 0);

  // --- Light for any non-emissive objects (later, for character) ---
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // --- Light Floor (ShaderMaterial) ---
  const floorSize = 20;
  const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize, 1, 1);
  floorGeo.rotateX(-Math.PI / 2); // make it lie flat on XZ

  const uniforms = {
    u_time: { value: 0.0 }
  };

  const floorMat = new THREE.ShaderMaterial({
    uniforms,
    transparent: false,
    side: THREE.DoubleSide,
    fragmentShader: /* glsl */`
      precision highp float;
      uniform float u_time;
      varying vec2 vUv;

      // simple grid function
      float grid(vec2 uv, float lines) {
        vec2 g = fract(uv * lines);
        vec2 border = min(g, 1.0 - g);
        float line = min(border.x, border.y);
        return smoothstep(0.03, 0.0, line);
      }

      void main() {
        // base color gradient
        vec2 uv = vUv - 0.5;
        float dist = length(uv * 2.0);
        float glow = exp(-dist * 2.5);

        // animated subtle pulse
        float pulse = 0.6 + 0.4 * sin(u_time * 2.0);

        // grid lines
        float g = grid(vUv, 10.0);

        vec3 baseColor = vec3(0.05, 0.8, 0.25);     // green base
        vec3 gridColor = vec3(0.3, 1.0, 0.6);       // bright green

        vec3 color = baseColor * glow * pulse;
        color += gridColor * g;

        gl_FragColor = vec4(color, 1.0);
      }
    `,
    vertexShader: /* glsl */`
      precision highp float;
      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `
  });

  const floor = new THREE.Mesh(floorGeo, floorMat);
  scene.add(floor);

  // --- Garden Surround ---
  // Large grass plane surrounding the light floor
  const gardenSize = 60;
  const gardenGeo = new THREE.PlaneGeometry(gardenSize, gardenSize, 1, 1);
  gardenGeo.rotateX(-Math.PI / 2);

  // Simple fake grass material using a standard material with color
  const gardenMat = new THREE.MeshStandardMaterial({
    color: 0x184d28, // deep green
    roughness: 1.0,
    metalness: 0.0
  });

  const garden = new THREE.Mesh(gardenGeo, gardenMat);
  garden.position.y = -0.01; // slightly below floor to avoid z-fighting
  scene.add(garden);

  // Add a low border hedge around the floor using instanced boxes
  const hedgeHeight = 0.6;
  const hedgeThickness = 0.4;
  const hedgeColor = 0x1f7a3b;
  const hedgeMat = new THREE.MeshStandardMaterial({ color: hedgeColor });

  // Create hedge segments along the four edges of the floor
  const hedgeSegments = [];
  const half = floorSize / 2;

  // Along X edges (front and back)
  const frontHedgeGeo = new THREE.BoxGeometry(floorSize, hedgeHeight, hedgeThickness);
  const backHedgeGeo = frontHedgeGeo.clone();
  const frontHedge = new THREE.Mesh(frontHedgeGeo, hedgeMat);
  frontHedge.position.set(0, hedgeHeight / 2, -half - hedgeThickness / 2);
  hedgeSegments.push(frontHedge);

  const backHedge = new THREE.Mesh(backHedgeGeo, hedgeMat);
  backHedge.position.set(0, hedgeHeight / 2, half + hedgeThickness / 2);
  hedgeSegments.push(backHedge);

  // Along Z edges (left and right)
  const sideHedgeGeo = new THREE.BoxGeometry(hedgeThickness, hedgeHeight, floorSize);
  const leftHedge = new THREE.Mesh(sideHedgeGeo, hedgeMat);
  leftHedge.position.set(-half - hedgeThickness / 2, hedgeHeight / 2, 0);
  hedgeSegments.push(leftHedge);

  const rightHedge = new THREE.Mesh(sideHedgeGeo, hedgeMat);
  rightHedge.position.set(half + hedgeThickness / 2, hedgeHeight / 2, 0);
  hedgeSegments.push(rightHedge);

  hedgeSegments.forEach(h => scene.add(h));

  // Scatter simple "plants" (cones) randomly in the garden area outside the floor
  const plantCount = 60;
  const plantGeo = new THREE.ConeGeometry(0.12, 0.5, 8);
  const plantMat = new THREE.MeshStandardMaterial({ color: 0x2fa74e });

  function isOutsideFloor(x, z) {
    return Math.abs(x) > half || Math.abs(z) > half;
  }

  for (let i = 0; i < plantCount; i++) {
    const x = (Math.random() - 0.5) * gardenSize;
    const z = (Math.random() - 0.5) * gardenSize;
    if (!isOutsideFloor(x, z)) { i--; continue; }
    const plant = new THREE.Mesh(plantGeo, plantMat);
    plant.position.set(x, 0.25, z);
    plant.rotation.y = Math.random() * Math.PI * 2;
    scene.add(plant);
  }

  // --- Resize handling ---
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // --- Animation loop ---
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    uniforms.u_time.value = t;

    controls.update();

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
