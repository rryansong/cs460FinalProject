<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Light Floor Demo</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #ui {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      background: rgba(12, 18, 14, 0.65);
      color: #e6f7ec;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 8px 10px;
      border-radius: 8px;
      backdrop-filter: blur(3px);
      border: 1px solid rgba(140, 255, 200, 0.3);
    }
    #ui label { display: flex; align-items: center; gap: 6px; margin: 4px 0; }
    #ui input[type="range"] { width: 120px; }
    #ui .row { display: flex; align-items: center; gap: 8px; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
<div id="ui">
  <div class="row">
    <label>spark color <input type="color" id="sparkColor" value="#8affc6"></label>
  </div>
  <div class="row">
    <label>intensity <input type="range" id="sparkIntensity" min="0.5" max="2" step="0.05" value="1"></label>
  </div>
  <div class="row">
    <label>spark size <input type="range" id="humanSparkSize" min="0.5" max="20" step="0.05" value="1"></label>
  </div>
</div>
<div id="hint" style="position:fixed;top:12px;right:12px;z-index:10;background:rgba(12,12,12,0.6);color:#eaeaea;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial;padding:8px 10px;border-radius:8px;border:1px solid rgba(200,200,200,0.25);backdrop-filter:blur(3px)">
  WASD Blue<br/>↑↓←→ Red<br/><span style="opacity:0.7">R: Reset camera<br/>M: Music toggle</span>
</div>
<audio id="bgMusic" loop autoplay>
  <source src="shake-it-up-397500.mp3" type="audio/mpeg">
</audio>
<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { FontLoader } from 'three/addons/loaders/FontLoader.js';
  import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

  // --- Renderer ---
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- Scene & Camera ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x02040a);

  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    500
  );
  camera.position.set(0, 6, 10);
  camera.lookAt(0, 0, 0);

  // --- Controls (zoom, rotate, pan) ---
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = true;
  controls.enableZoom = true; // mouse wheel zoom
  controls.minDistance = 3;   // closest zoom
  controls.maxDistance = 40;  // farthest zoom
  controls.target.set(0, 0, 0);

  // --- Light for any non-emissive objects (later, for character) ---
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // --- Sky dome with drifting procedural clouds ---
  const skyUniforms = {
    u_time: { value: 0 }
  };

  const skyVertex = /* glsl */`
    varying vec3 vNormal;
    void main() {
      vNormal = normalize(normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const skyFragment = /* glsl */`
    precision highp float;
    varying vec3 vNormal;
    uniform float u_time;

    // 2D hash-based value noise
    float hash(vec2 p) {
      p = fract(p * vec2(123.34, 345.45));
      p += dot(p, p + 34.345);
      return fract(p.x * p.y);
    }

    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }

    float fbm(vec2 p) {
      float v = 0.0;
      float a = 0.5;
      mat2 m = mat2(1.6, -1.2, 1.2, 1.6);
      for (int i = 0; i < 5; i++) {
        v += a * noise(p);
        p = m * p;
        a *= 0.55;
      }
      return v;
    }

    void main() {
      // base gradient sky
      vec3 n = normalize(vNormal);
      float h = clamp(n.y * 0.5 + 0.5, 0.0, 1.0);
      vec3 horizon = vec3(0.18, 0.22, 0.35);
      vec3 zenith = vec3(0.62, 0.77, 0.95);
      vec3 sky = mix(horizon, zenith, pow(h, 0.65));

      // cloud layer
      float t = u_time * 0.05;
      // map normal to pseudo-uv on sphere
      vec2 uv = vec2(atan(n.z, n.x) / 6.28318 + 0.5, h);
      vec2 flow = uv * 3.8 + vec2(t * 0.9, t * 0.55);
      float clouds = fbm(flow);
      float mask = smoothstep(0.48, 0.62, clouds);
      float edges = smoothstep(0.2, 0.6, clouds);
      vec3 cloudColor = mix(vec3(1.0), vec3(0.9, 0.95, 1.0), 0.4);

      vec3 col = mix(sky, sky + cloudColor * 0.28, mask);
      col += cloudColor * edges * 0.05; // soft rim
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  const skyMat = new THREE.ShaderMaterial({
    uniforms: skyUniforms,
    vertexShader: skyVertex,
    fragmentShader: skyFragment,
    side: THREE.BackSide,
    depthWrite: false
  });

  const skyGeo = new THREE.SphereGeometry(120, 64, 32);
  const sky = new THREE.Mesh(skyGeo, skyMat);
  sky.frustumCulled = false;
  scene.add(sky);

  // --- Light Floor (ShaderMaterial) ---
  const floorSize = 20;
  const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize, 1, 1);
  floorGeo.rotateX(-Math.PI / 2); // make it lie flat on XZ

  const uniforms = {
    u_time: { value: 0.0 }
  };

  const floorMat = new THREE.ShaderMaterial({
    uniforms,
    transparent: false,
    side: THREE.DoubleSide,
    fragmentShader: /* glsl */`
      precision highp float;
      uniform float u_time;
      varying vec2 vUv;

      void main() {
        // flat dark floor (no pulse, no grid)
        vec3 color = vec3(0.01, 0.01, 0.015);

        gl_FragColor = vec4(color, 1.0);
      }
    `,
    vertexShader: /* glsl */`
      precision highp float;
      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `
  });

  const floor = new THREE.Mesh(floorGeo, floorMat);
  scene.add(floor);

  const half = floorSize / 2;

  // Position camera to see the entire floor with an angled view (not top-down)
  function frameFloor() {
    const w = renderer.domElement.clientWidth || window.innerWidth;
    const h = renderer.domElement.clientHeight || window.innerHeight;
    const aspect = w / h;
    const vFov = THREE.MathUtils.degToRad(camera.fov);
    const hFov = 2 * Math.atan(Math.tan(vFov / 2) * aspect);
    const effFov = Math.min(vFov, hFov);
    const radius = half * Math.SQRT2; // bounding sphere radius of the square floor
    const dist = (radius / Math.sin(effFov / 2)) * 0.8; // smaller margin for a closer view

    const az = THREE.MathUtils.degToRad(0); // yaw: 0 = front view along +Z
    const el = THREE.MathUtils.degToRad(40); // elevation above XZ plane
    const cosEl = Math.cos(el), sinEl = Math.sin(el);
    const sinAz = Math.sin(az), cosAz = Math.cos(az);
    const x = dist * cosEl * sinAz;
    const y = dist * sinEl;
    const z = dist * cosEl * cosAz;
    camera.position.set(x, y, z);
    camera.lookAt(0, 0, 0);
    controls.target.set(0, 0, 0);
    controls.update();
  }

  // Set initial view to cover the full floor
  frameFloor();
  
    // --- Floating Sky Text: HAPPY CHASE ---
    const skyTexts = [];
    const fontLoader = new FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
      const textMatLeft = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x000000,
        emissiveIntensity: 0.0,
        metalness: 0.0,
        roughness: 0.6
      });
      const textMatRight = textMatLeft.clone();

      const makeText = (txt, size = 0.8) => {
        const geo = new TextGeometry(txt, {
          font,
          size,
          height: 0.1,
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 0.015,
          bevelSize: 0.008,
          bevelSegments: 3
        });
        geo.computeBoundingBox();
        geo.center();
        const mesh = new THREE.Mesh(geo, txt === 'HAPPY' ? textMatLeft : textMatRight);
        return mesh;
      };

      const happy = makeText('HAPPY', 0.85);
      const chase = makeText('CHASE', 0.85);
      happy.position.set(-3.6, 5.6, -1.0);
      chase.position.set( 3.6, 5.6,  1.0);
      scene.add(happy, chase);
      skyTexts.push({ mesh: happy, basePos: happy.position.clone(), phase: 0.0, hueOffset: 0.0 });
      skyTexts.push({ mesh: chase, basePos: chase.position.clone(), phase: Math.PI * 0.5, hueOffset: 0.35 });
    });

  // --- Background Music ---
  const bgMusic = document.getElementById('bgMusic');
  bgMusic.volume = 0.4;
  let musicPlaying = true;
  // Auto-play on page load
  bgMusic.play().catch(err => {
    // Browser may block autoplay, user can press M to start
    musicPlaying = false;
    console.log('Autoplay blocked, press M to start music');
  });

  const boundaryMargin = 0.6; // keep characters inside floor
  const clampVal = (v, min, max) => Math.max(min, Math.min(max, v));

  // --- Block Person (cubes & rectangles) ---
  function createBlockPerson() {
    const person = new THREE.Group();

    const skinMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
    const shirtMat = new THREE.MeshStandardMaterial({ color: 0x3366ff });
    const pantMat = new THREE.MeshStandardMaterial({ color: 0x222244 });
    const shoeMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

    // Torso (rectangle)
    const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.6), shirtMat);
    torso.name = 'torso';
    torso.position.set(0, 1.1, 0);
    person.add(torso);

    // Head (cube)
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), skinMat);
    head.position.set(0, 2.2, 0);
    person.add(head);

    // Simple eyes (small rectangles)
    const eyeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.02);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.17, 2.3, 0.41);
    rightEye.position.set(0.17, 2.3, 0.41);
    person.add(leftEye, rightEye);

    // Arms (rectangles)
    const armGeo = new THREE.BoxGeometry(0.4, 1.0, 0.4);
    const leftArm = new THREE.Mesh(armGeo, shirtMat);
    leftArm.name = 'leftArm';
    leftArm.position.set(-0.9, 1.2, 0);
    const rightArm = new THREE.Mesh(armGeo, shirtMat);
    rightArm.name = 'rightArm';
    rightArm.position.set(0.9, 1.2, 0);
    person.add(leftArm, rightArm);

    // Hands (cubes)
    const handGeo = new THREE.BoxGeometry(0.35, 0.35, 0.35);
    const leftHand = new THREE.Mesh(handGeo, skinMat);
    leftHand.position.set(-0.9, 0.75, 0);
    const rightHand = new THREE.Mesh(handGeo, skinMat);
    rightHand.position.set(0.9, 0.75, 0);
    person.add(leftHand, rightHand);

    // Legs (longer) using pivots for swing animation
    const legLength = 1.4;
    const legGeo = new THREE.BoxGeometry(0.5, legLength, 0.5);

    const leftLegPivot = new THREE.Group();
    const rightLegPivot = new THREE.Group();
    // Place pivots at hip height under torso
    const hipY = 1.1; // approx bottom of torso
    leftLegPivot.position.set(-0.3, hipY, 0);
    rightLegPivot.position.set(0.3, hipY, 0);

    const leftLeg = new THREE.Mesh(legGeo, pantMat);
    const rightLeg = new THREE.Mesh(legGeo, pantMat);
    // Offset legs down so rotation happens at hip
    leftLeg.position.set(0, -legLength / 2, 0);
    rightLeg.position.set(0, -legLength / 2, 0);

    leftLegPivot.add(leftLeg);
    rightLegPivot.add(rightLeg);
    person.add(leftLegPivot, rightLegPivot);

    // Shoes attached to leg pivots so they follow rotation
    const shoeGeo = new THREE.BoxGeometry(0.6, 0.25, 0.7);
    const leftShoe = new THREE.Mesh(shoeGeo, shoeMat);
    leftShoe.name = 'leftShoe';
    const rightShoe = new THREE.Mesh(shoeGeo, shoeMat);
    rightShoe.name = 'rightShoe';
    const shoeYOffset = -legLength - 0.125; // bottom offset relative to pivot
    leftShoe.position.set(0, shoeYOffset, 0.1);
    rightShoe.position.set(0, shoeYOffset, 0.1);
    leftLegPivot.add(leftShoe);
    rightLegPivot.add(rightShoe);

    // Foot markers to detect contact
    const leftFootMarker = new THREE.Object3D();
    const rightFootMarker = new THREE.Object3D();
    leftFootMarker.position.set(0, shoeYOffset - 0.02, 0.1);
    rightFootMarker.position.set(0, shoeYOffset - 0.02, 0.1);
    leftLegPivot.add(leftFootMarker);
    rightLegPivot.add(rightFootMarker);

    // Store refs for animation
    person.userData.leftLegPivot = leftLegPivot;
    person.userData.rightLegPivot = rightLegPivot;
    person.userData.leftFootMarker = leftFootMarker;
    person.userData.rightFootMarker = rightFootMarker;

    return person;
  }

  const blockPerson = createBlockPerson();
  blockPerson.scale.setScalar(0.75);
  blockPerson.position.set(0, 0.32, 0); // adjusted for scaled feet to contact ground
  scene.add(blockPerson);

  // Red mini person
  function createRedPerson() {
    const p = createBlockPerson();
    // Set only torso to red; keep other parts same as blue person
    p.traverse((child) => {
      if (child.isMesh && child.name === 'torso') {
        child.material = child.material.clone();
        child.material.color.setHex(0xcc3333);
      }
    });
    p.scale.setScalar(0.75);
    return p;
  }

  const redPerson = createRedPerson();
  redPerson.position.set(2.5, 0.32, 1.5);
  scene.add(redPerson);

  // UI controls for spark visuals
  const sparkColorInput = document.getElementById('sparkColor');
  const sparkIntensityInput = document.getElementById('sparkIntensity');
  const humanSparkSizeInput = document.getElementById('humanSparkSize');
  const getSparkColor = () => new THREE.Color(sparkColorInput?.value || '#8affc6');
  const getSparkIntensity = () => parseFloat(sparkIntensityInput?.value || '1');
  const getHumanSparkSize = () => parseFloat(humanSparkSizeInput?.value || '1');

  // --- Simple wandering cats ---
  function createCat(color = 0xff7744, scale = 0.6) {
    const g = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color });
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.28, 0.3), mat);
    body.position.y = 0.28 / 2;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.28, 0.28), mat);
    head.position.set(0.42, 0.28, 0);
    const ear1 = new THREE.Mesh(new THREE.ConeGeometry(0.07, 0.12, 4), mat);
    ear1.position.set(0.52, 0.42, 0.08);
    ear1.rotation.z = Math.PI;
    const ear2 = ear1.clone();
    ear2.position.z = -0.08;
    const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.45, 6), mat);
    tail.position.set(-0.38, 0.32, 0);
    tail.rotation.z = Math.PI / 4;
    g.add(body, head, ear1, ear2, tail);
    g.scale.setScalar(scale);
    return g;
  }

  const cats = [];
  function addCatAt(x, z, color) {
    const c = createCat(color);
    c.position.set(x, 0.15, z);
    scene.add(c);
    const dir = new THREE.Vector2((Math.random()-0.5), (Math.random()-0.5)).normalize();
    // add four paw markers (front-left, front-right, rear-left, rear-right)
    const s = c.scale.x;
    const dx = 0.22 * (1.0 / 0.6) * s; // compensate for base scale
    const dz = 0.12 * (1.0 / 0.6) * s;
    const yPaw = 0.01;
    const fl = new THREE.Object3D(); fl.position.set( +dx, yPaw, +dz );
    const fr = new THREE.Object3D(); fr.position.set( +dx, yPaw, -dz );
    const rl = new THREE.Object3D(); rl.position.set( -dx, yPaw, +dz );
    const rr = new THREE.Object3D(); rr.position.set( -dx, yPaw, -dz );
    c.add(fl, fr, rl, rr);
    cats.push({
      obj: c,
      vel: dir.multiplyScalar(2.6),
      turnTimer: 0.0,
      speed: 2.6,
      phase: 0,
      paws: { fl, fr, rl, rr },
      contact: { fl: false, fr: false, rl: false, rr: false },
      pauseTimer: 0.0,
      hearts: [],
      rearmCollide: false
    });
  }

  // place two cats inside the floor bounds
  addCatAt(half * 0.5, half * 0.2, 0xffffff);
  addCatAt(-half * 0.4, -half * 0.1, 0xffaa55);

  // --- Arrow-keys movement & walking animation ---
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.code);
    // Press 'R' to reset camera to initial framing
    if (e.code === 'KeyR') {
      frameFloor();
    }
    // Press 'M' to toggle music
    if (e.code === 'KeyM') {
      if (!musicPlaying) {
        bgMusic.play().catch(err => console.log('Play failed:', err));
        musicPlaying = true;
      } else {
        bgMusic.pause();
        musicPlaying = false;
      }
    }
  });
  window.addEventListener('keyup', (e) => {
    keys.delete(e.code);
  });

  const moveSpeed = 3.0; // units per second
  const swingAmplitude = 0.7; // radians, longer stride
  const stepHz = 2.0; // 0.5s per step (2 steps per second)
  const blueState = { walkPhase: 0, leftInContact: false, rightInContact: false };
  const redState = { walkPhase: 0, leftInContact: false, rightInContact: false };

  // Spark particle effect (shader-based, per-particle fade & size)
  const sparkEmitters = [];
  const sparkVertex = /* glsl */`
    attribute float aLife;
    attribute float aSize;
    varying float vLife;
    void main() {
      vLife = aLife;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = aSize * (1.0 - vLife) * (300.0 / -mvPosition.z);
      gl_Position = projectionMatrix * mvPosition;
    }
  `;
  const sparkFragment = /* glsl */`
    precision highp float;
    uniform vec3 uColor;
    varying float vLife;
    void main() {
      vec2 uv = gl_PointCoord - 0.5;
      float d = length(uv);
      float alpha = smoothstep(0.45, 0.2, 0.5 - d);
      alpha *= (1.0 - vLife);
      // subtle center bloom
      float bloom = exp(-12.0 * d * d);
      vec3 col = mix(uColor * 0.4, uColor, bloom);
      gl_FragColor = vec4(col, alpha);
    }
  `;

  function spawnSparks(pos, { count = 150, duration = 1.0, size = 0.1, color = new THREE.Color(0x8affc6), slow = false, speedScale = 1.0 } = {}) {
    const positions = new Float32Array(count * 3);
    const velocities = new Float32Array(count * 3);
    const life = new Float32Array(count);
    const sizes = new Float32Array(count);
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const baseSpeed = slow ? 1.6 : 3.6; // faster spread to reach ~grid-cell scale
      const varSpeed = slow ? 2.0 : 4.0;
      const speed = (baseSpeed + Math.random() * varSpeed) * speedScale;
      const vx = Math.cos(a) * speed;
      const vz = Math.sin(a) * speed;
      const vy = (slow ? 0.6 : 2.0) * Math.random();
      positions[i * 3 + 0] = pos.x + (Math.random() - 0.5) * 0.04;
      positions[i * 3 + 1] = 0.02 + pos.y;
      positions[i * 3 + 2] = pos.z + (Math.random() - 0.5) * 0.04;
      velocities[i * 3 + 0] = vx;
      velocities[i * 3 + 1] = vy;
      velocities[i * 3 + 2] = vz;
      life[i] = 0;
      sizes[i] = size * (0.8 + Math.random() * 0.6);
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('aLife', new THREE.BufferAttribute(life, 1));
    geo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
    const mat = new THREE.ShaderMaterial({
      uniforms: { uColor: { value: color.clone() } },
      vertexShader: sparkVertex,
      fragmentShader: sparkFragment,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const points = new THREE.Points(geo, mat);
    scene.add(points);
    sparkEmitters.push({
      points,
      positions,
      velocities,
      life,
      sizes,
      age: 0,
      duration,
      baseSize: size
    });
  }

  function spawnCompositeSparks(pos) {
    const intensity = getSparkIntensity();
    const color = getSparkColor();
    const s = getHumanSparkSize();
    // fewer particles when larger, but spread further and last a bit longer
    const countScale = 1 / Math.pow(s, 0.8);
    const speedScale = 1 + 0.9 * (s - 1);
    const mainCount = Math.max(40, Math.round(220 * intensity * countScale));
    const trailCount = Math.max(30, Math.round(140 * intensity * countScale));
    const mainDuration = Math.min(2.0, 1.0 * (1 + 0.25 * (s - 1)));
    const trailDuration = Math.min(2.4, 1.6 * (1 + 0.25 * (s - 1)));
    // main burst
    spawnSparks(pos, { count: mainCount, duration: mainDuration, size: 0.12 * intensity * s, color, speedScale });
    // afterglow / trail-like slower sparks
    spawnSparks(pos, { count: trailCount, duration: trailDuration, size: 0.09 * intensity * s, color: color.clone().multiplyScalar(0.8), slow: true, speedScale });
  }

  // Cat variant: smaller sparks regardless of human size control
  function spawnCompositeSparksCat(pos) {
    const intensity = getSparkIntensity();
    const color = getSparkColor();
    spawnSparks(pos, { count: Math.round(180 * intensity), duration: 0.9, size: 0.06 * intensity, color });
    spawnSparks(pos, { count: Math.round(110 * intensity), duration: 1.2, size: 0.045 * intensity, color: color.clone().multiplyScalar(0.85), slow: true });
  }

  function updateSparks(dt) {
    const gravity = 9.8;
    const drag = 0.86;
    for (let i = sparkEmitters.length - 1; i >= 0; i--) {
      const e = sparkEmitters[i];
      e.age += dt;
      const t = Math.min(1, e.age / e.duration);
      // integrate
      for (let j = 0; j < e.positions.length; j += 3) {
        e.velocities[j + 1] -= gravity * dt * 0.6;
        e.velocities[j + 0] *= drag;
        e.velocities[j + 1] *= drag;
        e.velocities[j + 2] *= drag;
        e.positions[j + 0] += e.velocities[j + 0] * dt;
        e.positions[j + 1] += e.velocities[j + 1] * dt;
        e.positions[j + 2] += e.velocities[j + 2] * dt;
        // floor collide: clamp to y ~ 0, add small rebound
        if (e.positions[j + 1] < 0.01) {
          e.positions[j + 1] = 0.01;
          e.velocities[j + 1] *= -0.25;
        }
        e.life[j / 3] = t;
      }
      e.points.geometry.attributes.position.needsUpdate = true;
      e.points.geometry.attributes.aLife.needsUpdate = true;
      if (e.age >= e.duration) {
        scene.remove(e.points);
        e.points.geometry.dispose();
        e.points.material.dispose();
        sparkEmitters.splice(i, 1);
      }
    }
  }

  // --- Heart sprites for affection effect ---
  function makeHeartSprite(color = '#ff6aa2') {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,128,128);
    // background transparent
    const cx = 64, cy = 64, s = 34;
    const grad = ctx.createRadialGradient(cx, cy + 10, 8, cx, cy, 56);
    grad.addColorStop(0, color);
    grad.addColorStop(1, '#ff3a7a');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(cx, cy + s * 0.4);
    ctx.bezierCurveTo(cx - s, cy - s * 0.2, cx - s * 1.1, cy + s * 0.7, cx, cy + s * 1.2);
    ctx.bezierCurveTo(cx + s * 1.1, cy + s * 0.7, cx + s, cy - s * 0.2, cx, cy + s * 0.4);
    ctx.closePath();
    ctx.shadowColor = color;
    ctx.shadowBlur = 12;
    ctx.fill();
    const tex = new THREE.CanvasTexture(canvas);
    tex.needsUpdate = true;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
    const spr = new THREE.Sprite(mat);
    spr.scale.set(0.45, 0.45, 1);
    return spr;
  }

  function spawnHeartsForCat(cat) {
    const nowHearts = [];
    const basePos = new THREE.Vector3();
    cat.obj.getWorldPosition(basePos);
    const delays = [0, 0.25, 0.5, 0.75, 1.0];
    for (let i = 0; i < 5; i++) {
      const spr = makeHeartSprite('#ff79b0');
      spr.position.copy(basePos).add(new THREE.Vector3(0, 0.55, 0));
      spr.visible = false;
      scene.add(spr);
      // random gentle sideways drift
      const drift = new THREE.Vector2((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
      nowHearts.push({ sprite: spr, delay: delays[i], age: 0, duration: 2.2, active: false, drift });
    }
    cat.hearts.push(...nowHearts);
  }

  // Foot contact detection state
  let leftInContact = false;
  let rightInContact = false;

  // --- Resize handling ---
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // --- Animation loop ---
  const clock = new THREE.Clock();
  let timeAccum = 0;

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    timeAccum += dt;
    uniforms.u_time.value = timeAccum;
    skyUniforms.u_time.value = timeAccum;

    // Bob and spin floating sky text
    for (const st of skyTexts) {
      st.mesh.position.y = st.basePos.y + Math.sin(timeAccum * 0.8 + st.phase) * 0.4;
      st.mesh.rotation.y += 0.12 * dt;
      // Animate rainbow colors
      const hue = (timeAccum * 0.2 + st.hueOffset) % 1.0;
      st.mesh.material.color.setHSL(hue, 0.85, 0.6);
      if (st.mesh.material.emissive) {
        st.mesh.material.emissive.setHSL(hue, 0.6, 0.3);
        st.mesh.material.emissiveIntensity = 0.35;
      }
    }

    // Movement input for two players
    let dirBlueX = 0, dirBlueZ = 0; // WASD for blue
    if (keys.has('KeyW')) dirBlueZ -= 1;
    if (keys.has('KeyS')) dirBlueZ += 1;
    if (keys.has('KeyA')) dirBlueX -= 1;
    if (keys.has('KeyD')) dirBlueX += 1;

    let dirRedX = 0, dirRedZ = 0; // Arrows for red
    if (keys.has('ArrowUp')) dirRedZ -= 1;
    if (keys.has('ArrowDown')) dirRedZ += 1;
    if (keys.has('ArrowLeft')) dirRedX -= 1;
    if (keys.has('ArrowRight')) dirRedX += 1;

    const dirBlueLen = Math.hypot(dirBlueX, dirBlueZ);
    const dirRedLen = Math.hypot(dirRedX, dirRedZ);
    // Move blue person
    let blueSpeed = 0;
    if (dirBlueLen > 0) {
      const nx = dirBlueX / dirBlueLen;
      const nz = dirBlueZ / dirBlueLen;
      blueSpeed = moveSpeed;
      blockPerson.position.x += nx * blueSpeed * dt;
      blockPerson.position.z += nz * blueSpeed * dt;
      blockPerson.rotation.y = Math.atan2(nx, nz);
    }
    // clamp inside bounds
    blockPerson.position.x = clampVal(blockPerson.position.x, -half + boundaryMargin, half - boundaryMargin);
    blockPerson.position.z = clampVal(blockPerson.position.z, -half + boundaryMargin, half - boundaryMargin);

    // Move red person
    let redSpeed = 0;
    if (dirRedLen > 0) {
      const nx = dirRedX / dirRedLen;
      const nz = dirRedZ / dirRedLen;
      redSpeed = moveSpeed;
      redPerson.position.x += nx * redSpeed * dt;
      redPerson.position.z += nz * redSpeed * dt;
      redPerson.rotation.y = Math.atan2(nx, nz);
    }
    // clamp inside bounds
    redPerson.position.x = clampVal(redPerson.position.x, -half + boundaryMargin, half - boundaryMargin);
    redPerson.position.z = clampVal(redPerson.position.z, -half + boundaryMargin, half - boundaryMargin);

    // Walk leg swing animation
    // Walk leg swing animation for blue
    const bLP = blockPerson.userData.leftLegPivot;
    const bRP = blockPerson.userData.rightLegPivot;
    const bLF = blockPerson.userData.leftFootMarker;
    const bRF = blockPerson.userData.rightFootMarker;
    if (bLP && bRP) {
      const phaseRate = (blueSpeed > 0 ? stepHz : 0.5) * Math.PI * 2.0;
      blueState.walkPhase += phaseRate * dt;
      const swing = Math.sin(blueState.walkPhase) * (blueSpeed > 0 ? swingAmplitude : swingAmplitude * 0.2);
      bLP.rotation.x = swing;
      bRP.rotation.x = -swing;
    }

    // Walk leg swing animation for red
    const rLP = redPerson.userData.leftLegPivot;
    const rRP = redPerson.userData.rightLegPivot;
    const rLF = redPerson.userData.leftFootMarker;
    const rRF = redPerson.userData.rightFootMarker;
    if (rLP && rRP) {
      const phaseRate = (redSpeed > 0 ? stepHz : 0.5) * Math.PI * 2.0;
      redState.walkPhase += phaseRate * dt;
      const swing = Math.sin(redState.walkPhase) * (redSpeed > 0 ? swingAmplitude : swingAmplitude * 0.2);
      rLP.rotation.x = swing;
      rRP.rotation.x = -swing;
    }

    // Foot contact detection and sparks for both
    const tmp = new THREE.Vector3();
    if (bLF) {
      bLF.getWorldPosition(tmp);
      const contact = tmp.y <= 0.05;
      if (contact && !blueState.leftInContact) spawnCompositeSparks(tmp);
      blueState.leftInContact = contact;
    }
    if (bRF) {
      bRF.getWorldPosition(tmp);
      const contact = tmp.y <= 0.05;
      if (contact && !blueState.rightInContact) spawnCompositeSparks(tmp);
      blueState.rightInContact = contact;
    }
    if (rLF) {
      rLF.getWorldPosition(tmp);
      const contact = tmp.y <= 0.05;
      if (contact && !redState.leftInContact) spawnCompositeSparks(tmp);
      redState.leftInContact = contact;
    }
    if (rRF) {
      rRF.getWorldPosition(tmp);
      const contact = tmp.y <= 0.05;
      if (contact && !redState.rightInContact) spawnCompositeSparks(tmp);
      redState.rightInContact = contact;
    }

    updateSparks(dt);

    // Update wandering cats
    for (const c of cats) {
      // collision with players triggers pause and hearts
      const collideDist = 0.7;
      const dxB = c.obj.position.x - blockPerson.position.x;
      const dzB = c.obj.position.z - blockPerson.position.z;
      const dxR = c.obj.position.x - redPerson.position.x;
      const dzR = c.obj.position.z - redPerson.position.z;
      const dB2 = dxB*dxB + dzB*dzB;
      const dR2 = dxR*dxR + dzR*dzR;
      if (!c.rearmCollide && (dB2 < collideDist*collideDist || dR2 < collideDist*collideDist)) {
        // no stopping; just hearts and set rearm latch
        c.turnTimer = c.turnTimer; // no change
        c.rearmCollide = true;
        spawnHeartsForCat(c);
      }

      c.turnTimer -= dt;
      if (c.turnTimer <= 0) {
        // random small turn
        const ang = (Math.random() - 0.5) * Math.PI * 0.5;
        const cos = Math.cos(ang), sin = Math.sin(ang);
        const vx = c.vel.x * cos - c.vel.y * sin;
        const vz = c.vel.x * sin + c.vel.y * cos;
        c.vel.set(vx, vz).setLength(c.speed * (0.7 + 0.6 * Math.random()));
        c.turnTimer = 0.6 + Math.random() * 1.2;
      }
      // move and bound
      c.obj.position.x += c.vel.x * dt;
      c.obj.position.z += c.vel.y * dt;
      // keep within floor bounds with soft steering
      const margin = boundaryMargin;
      if (c.obj.position.x > half - margin || c.obj.position.x < -half + margin) {
        c.vel.x *= -1;
      }
      if (c.obj.position.z > half - margin || c.obj.position.z < -half + margin) {
        c.vel.y *= -1;
      }
      // clamp in case of overshoot
      c.obj.position.x = clampVal(c.obj.position.x, -half + margin, half - margin);
      c.obj.position.z = clampVal(c.obj.position.z, -half + margin, half - margin);
      // face moving direction
      c.obj.rotation.y = Math.atan2(c.vel.x, c.vel.y);
      // after a hit, require separation before next trigger
      if (c.rearmCollide) {
        const rearmDist = collideDist * 1.3;
        const rearm2 = rearmDist * rearmDist;
        if (dB2 > rearm2 && dR2 > rearm2) {
          c.rearmCollide = false;
        }
      }

      // gait sparks: four paws alternating
      const speedLen = Math.hypot(c.vel.x, c.vel.y);
      const stepHzCat = Math.max(0.8, Math.min(3.5, speedLen / 1.2));
      c.phase += stepHzCat * Math.PI * 2.0 * dt;
      const offsets = {
        fl: 0.0,
        rr: 0.0, // diagonal pair in phase
        fr: Math.PI,
        rl: Math.PI
      };
      const tmpP = new THREE.Vector3();
      for (const key of ['fl','fr','rl','rr']) {
        const phase = c.phase + offsets[key];
        const down = Math.sin(phase) < -0.2 && speedLen > 0.2;
        if (down && !c.contact[key]) {
          c.paws[key].getWorldPosition(tmpP);
          spawnCompositeSparksCat(tmpP);
        }
        c.contact[key] = down;
      }

      // update hearts for this cat
      for (let i = c.hearts.length - 1; i >= 0; i--) {
        const h = c.hearts[i];
        if (!h.active) {
          h.delay -= dt;
          if (h.delay <= 0) {
            h.active = true;
            h.sprite.visible = true;
          }
        } else {
          h.age += dt;
          const t = Math.min(1, h.age / h.duration);
          // keep spawning point above head
          const headPos = new THREE.Vector3();
          c.obj.getWorldPosition(headPos);
          h.sprite.position.copy(headPos).add(new THREE.Vector3(0, 0.55 + t * 1.5, 0));
          h.sprite.position.x += h.drift.x * t;
          h.sprite.position.z += h.drift.y * t;
          h.sprite.material.opacity = 1.0 - t;
          const s = 0.35 + 0.35 * t;
          h.sprite.scale.set(s, s, 1);
          if (h.age >= h.duration) {
            scene.remove(h.sprite);
            h.sprite.material.map.dispose();
            h.sprite.material.dispose();
            c.hearts.splice(i, 1);
          }
        }
      }
    }

    controls.update();

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
